#+title: Current Emacs configuration
#+author: Simon Meyer
Don't forget to check =init.el= and =early-init.el= for what comes before (such as =use-package= setup, sources and removing useless UI elements).
* Basic cosmetics and helpful stuff
This section configures the basic functions. Here we will remove the startup message, the scroll-bar, the tool-tips, the menu bar, and add 10 px of padding on each window.  We use the visible bell instead of the beep. Finally we disable the line numbers for some modes.
** All the icons
Package =all-the-icons= provides all the necessary icons to make everything nice and pretty. It provides icons for treemacs, the modeline and everything else. Don't forget to run =M-x all-the-icons-install-fonts= the first time to install all the fonts!
More info is available here: https://github.com/domtronn/all-the-icons.el
#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons
    :if (display-graphic-p))


  (use-package all-the-icons-completion)
  (run-with-timer 2 nil #'all-the-icons-completion-mode)  

 #+END_SRC

#+RESULTS:
: [nil 25691 14272 274889 nil all-the-icons-completion-mode nil nil 200000 nil]


** Theme
We can use any theme we want, =doom-themes= provides a nice, high-quality selection. I like doom city lights at the moment so lets stick with that. More info available here: https://github.com/hlissner/emacs-doom-themes
#+BEGIN_SRC emacs-lisp
;  (use-package doom-themes
;    :config (load-theme 'doom-city-lights t))
#+END_SRC

#+RESULTS:

I changed my mind, let's go for =modus-vivendi= instead. It is already included in emacs by default, but ;ore information can be found here nevertheless: https://protesilaos.com/emacs/modus-themes
#+BEGIN_SRC emacs-lisp
(setq modus-themes-mode-line '(borderless accented padded))
(setq modus-themes-region '(bg-only))
(setq modus-themes-completions 'opinionated)
(use-package modus-themes
  :config (load-theme 'modus-vivendi t))
#+END_SRC

#+RESULTS:
: t

** Modeline
*** Doom modeline
The modeline can be customized to our heats content. We will use one of =doom-modeline= here. Height is reduced to 15 as 25 is a bit big :).
Additional help and configuration can be found here:
https://github.com/seagle0128/doom-modeline
#+BEGIN_SRC emacs-lisp
(use-package doom-modeline
 :init
 (doom-modeline-mode 1)
 ;:hook
 ;(after-init . doom-modeline-init)
 :custom
 (doom-modeline-height 15)
 (doom-modeline-icon (display-graphic-p))
 (doom-modeline-env-version t))
#+END_SRC

#+RESULTS:

*** No minor modes in modeline please 
Minor modes in the modeline can be quite annoying, lets get rid of them here. We will use the =diminish= package for this.
Basic information can be found here:https://github.com/myrjola/diminish.el
#+BEGIN_SRC emacs-lisp
(use-package diminish)
#+END_SRC

#+RESULTS:

** Rainbow delimiters
Parentheses can be a real pain, so we use the color-coding to help identify who is who. We only use this in programming modes however as it can easily become distracting or irritating if we are only taking notes.
Documentation here: https://github.com/Fanael/rainbow-delimiters
#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :diminish rainbow-delimiters-mode
  :hook (prog-mode . rainbow-delimiters-mode))
#+END_SRC

#+RESULTS:
| rainbow-delimiters-mode |

** Dashboard
=dashboard= creates a splash screen at startup, instead of starting on a scratch buffer.  It allows us to access recently used files, agenda quick access and recent projects. Very useful. More in documentation here: https://github.com/emacs-dashboard/emacs-dashboard
Recent projects are handled using recentf, info available here: https://www.emacswiki.org/emacs/RecentFiles
#+BEGIN_SRC emacs-lisp
  (use-package dashboard
    :ensure t
    :demand t
    :diminish dashboard-mode
    :init
    (progn 
      (setq dashboard-banner-logo-title "Welcome to Simon's Emacs config")
      (setq dashboard-center-content t)
      (setq dashboard-items '((recents  . 10)
                              (bookmarks . 10)
                              (agenda . 10)
                              (projects . 10)))

      (setq dashboard-set-heading-items t)
      (setq dashboard-set-file-icons t)
      (setq dashboard-set-navigator t)
      (setq dashboard-set-init-info t))
      :config
      (dashboard-setup-startup-hook)
      (dashboard-modify-heading-icons '((recents . "file-text"))))

  ;(setq initial-buffer-choice (lambda () (get-buffer "*dashboard*")))


  (use-package recentf
    :config
    (recentf-mode t)
    (setq recentf-max-saved-items 50))
#+END_SRC

#+RESULTS:
: t

** Font configuration
Here all the fonts are correctly configured for proper size, weight and font depending on context. I really like *Fira Code*. It can be obtained and installed here: https://github.com/tonsky/FiraCode

I use *Roboto* as the prose text font, it looks auite nive doesn't it ;). Available here: https://github.com/googlefonts/roboto
#+BEGIN_SRC emacs-lisp
(defvar runemacs/default-font-size 140)
(set-face-attribute 'default nil :font "Fira Code Retina" :height runemacs/default-font-size)

;; Set the fixed pitch face
(set-face-attribute 'fixed-pitch nil :font "Fira Code Retina" :height 170)

;; Set the variable pitch face
(set-face-attribute 'variable-pitch nil :font "Roboto" :height 190 :weight 'regular)
#+END_SRC

#+RESULTS:

** Helpful
When you learn emacs, you will need help, A LOT. Using the internal help will become invaluable to save time and understand how things work. Introducing =helpful= which is a significant upgrade on the built in =help= function. You will use it, like it or not:
#+BEGIN_SRC emacs-lisp
(use-package helpful
  ;:custom
  ;(counsel-describe-function-function #'helpful-callable)
  ;(counsel-describe-variable-function #'helpful-variable)
  :bind
  ([remap describe-function] . helpful-function)
  ([remap describe-command] . helpful-command)
  ([remap describe-key] . helpful-key))
#+END_SRC

#+RESULTS:
: helpful-key

** Sane defaults
The defaults in Emacs aren't considered /sane/ because they have been this way a long time, and the Emacs community is very slow to change these things. We will therefore change them to something friendlier. It's a big mess of things that will generally improve your quality of life.
#+BEGIN_SRC emacs-lisp

  ;; Let's disable all the scroll bars
  (scroll-bar-mode -1)

  ;; Don't beep at me
  (setq visible-bell t)
  ;; Answering just 'y' or 'n', instead of 'yes' and 'no' will do
  (defalias 'yes-or-no-p 'y-or-n-p)

  ;; Keep all backup and auto-save files in one directory
  (setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
  (setq auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)))

  ;; UTF-8 please
  (setq locale-coding-system 'utf-8) ; pretty
  (set-terminal-coding-system 'utf-8) ; pretty
  (set-keyboard-coding-system 'utf-8) ; pretty
  (set-selection-coding-system 'utf-8) ; please
  (prefer-coding-system 'utf-8) ; with sugar on top

  ;; Turn off the blinking cursor
  (blink-cursor-mode -1)

  (setq-default indent-tabs-mode nil) ; no let's use spaces
  (setq-default indicate-empty-lines t)

  ;; Don't count two spaces after a period as the end of a sentence.
  ;; Just one space is needed.
  (setq sentence-end-double-space nil)

  ;; delete the region when typing, just like as we expect nowadays.
  (delete-selection-mode t)
  ;; Highlight the corresponding opening/closing parentheses when the cursor is on one of them
  (show-paren-mode t)
  ;; Add the column number to the modeline
  (column-number-mode t)
  ;; Enables softwrapping of lines (puts all the text on screen) 
  (global-visual-line-mode)
  ;; Shows file paths with forward slashes (as expected on Unix systems)
  (setq uniquify-buffer-name-style 'forward)

  ;; -i gets alias definitions from .bash_profile
  (setq shell-command-switch "-i")

  ;; Map escape to cancel (like C-g)...
  (define-key isearch-mode-map [escape] 'isearch-abort)   ;; isearch
  (define-key isearch-mode-map "\e" 'isearch-abort)   ;; \e seems to work better for terminals
  (global-set-key [escape] 'keyboard-escape-quit)         ;; everywhere else

  ;; Keep files up to date when they change on disk
  (global-auto-revert-mode t)

  ;; Docview continuous scroll
  (setq doc-view-continuous t)

  ;; Enable winner-mode
  (winner-mode 1);

  ;; Use ripgrep
  (use-package rg)

  (grep-apply-setting
   'grep-find-command
   '("rg -n -H --no-heading -e '' $(git rev-parse --show-toplevel || pwd)" . 27)
   )
#+END_SRC

#+RESULTS:
: (rg -n -H --no-heading -e '' $(git rev-parse --show-toplevel || pwd) . 27)

** Dogears
Dogears keeps track of your location using the bookmark system. It acts similarly to the history of a web browser. It is very useful to backtrack if one gets lost, or worse, distracted. More info here: https://github.com/alphapapa/dogears.el

#+begin_src emacs-lisp
(use-package dogears)
#+end_src

#+RESULTS:

* Completion framework
What is a completion framework? Good question, I don't know myself. More seriously, it is a system that enables completions of anything that requires choosing from a list, such as file searching or commands. This functionality already exists in emacs but it is generally understood that it needs to be improved. There are many available that do more or less things depending on what is desired, but here we will settle for a simple =vertico= system.
** Vertico config
=vertico= is the completion framework currently in use. It's quite lighter and a bit faster than =ivy= or =helm=. =vertico= is designed to be very close in functionality to the integrated completion framework but much better. We'll just remap a few keys to be friendlier with evil mode. Extensive help can be found here:  https://github.com/minad/vertico (thanks minad)
#+BEGIN_SRC emacs-lisp
    (use-package vertico
      :custom
      (vertico-cycle t)
      :bind (:map vertico-map
                  ("C-j" . vertico-next)
                  ("C-k" . vertico-previous)
                  ("C-f" . vertico-exit)
                  :map minibuffer-local-map
                  ("M-h" . backward-kill-word))
      :init
      (vertico-mode))


;; Configure directory extension.
  (use-package vertico-directory
    :ensure nil
    ;; More convenient directory navigation commands
    :bind (:map vertico-map
                ("RET" . vertico-directory-enter)
                ("DEL" . vertico-directory-delete-char)
                ("M-DEL" . vertico-directory-delete-word))
    ;; Tidy shadowed file names
    :hook (rfn-eshadow-update-overlay . vertico-directory-tidy))

#+END_SRC

#+RESULTS:
: vertico-directory-delete-word

** Savehist config
=savehist= rearranges the list provided by vertico to sort by last used to have the most commonly used command or names at the top. Very handy and small. Extra info here: https://github.com/emacs-mirror/emacs/blob/master/lisp/savehist.el
#+BEGIN_SRC emacs-lisp
(use-package savehist
  :init
  (savehist-mode))
#+END_SRC

#+RESULTS:

** Orderless
Searching for commands or files can be tricky as one does not always know the exact name. =orderless= is a neat tool that enables fuzzy searching and better keyword search all round. Very neat, more information can be found here:  
https://github.com/oantolin/orderless
#+BEGIN_SRC emacs-lisp
(use-package orderless
  :ensure t
  :custom (completion-styles '(orderless)))
#+END_SRC

#+RESULTS:

** Marginalia
=marginalia= provides extra information in the list provided by =vertico=. It adds a useful description to each line. More information here: https://github.com/minad/marginalia/
#+BEGIN_SRC emacs-lisp
(use-package marginalia
  :bind
  (:map minibuffer-local-map
        ("M-A" . marginalia-cycle))
  :custom
  (marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil))
  :init
  (marginalia-mode))
#+END_SRC

#+RESULTS:
: marginalia-cycle

** Consult
=consult= provides additional completion and quicker buffer switching, file searching, line searching etc. Don't forget to remap the keys to replace the original functions with these new ones Simon. 
Lots of documentation here: https://github.com/minad/consult
#+BEGIN_SRC emacs-lisp
;; Example configuration for Consult
 (use-package consult
  ;; Replace bindings. Lazily loaded due by `use-package'.
  :bind (;; C-c bindings in `mode-specific-map'
         ("C-c M-x" . consult-mode-command)
         ("C-c h" . consult-history)
         ("C-c k" . consult-kmacro)
         ("C-c m" . consult-man)
         ("C-c i" . consult-info)
         ([remap Info-search] . consult-info)
         ;; C-x bindings in `ctl-x-map'
         ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complex-command
         ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
         ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
         ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
         ("C-x r b" . consult-bookmark)            ;; orig. bookmark-jump
         ("C-x p b" . consult-project-buffer)      ;; orig. project-switch-to-buffer
         ;; Custom M-# bindings for fast register access
         ("M-#" . consult-register-load)
         ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
         ("C-M-#" . consult-register)
         ;; Other custom bindings
         ("M-y" . consult-yank-pop)                ;; orig. yank-pop
         ;; M-g bindings in `goto-map'
         ("M-g e" . consult-compile-error)
         ("M-g f" . consult-flymake)               ;; Alternative: consult-flycheck
         ("M-g g" . consult-goto-line)             ;; orig. goto-line
         ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
         ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
         ("M-g m" . consult-mark)
         ("M-g k" . consult-global-mark)
         ("M-g i" . consult-imenu)
         ("M-g I" . consult-imenu-multi)
         ;; M-s bindings in `search-map'
         ("M-s d" . consult-find)
         ("M-s D" . consult-locate)
         ("M-s g" . consult-grep)
         ("M-s G" . consult-git-grep)
         ("M-s r" . consult-ripgrep)
         ("M-s l" . consult-line)
         ("M-s L" . consult-line-multi)
         ("M-s k" . consult-keep-lines)
         ("M-s u" . consult-focus-lines)
         ;; Isearch integration
         ("M-s e" . consult-isearch-history)
         :map isearch-mode-map
         ;;("M-e" . consult-isearch-history)         ;; orig. isearch-edit-string
         ;;("M-s e" . consult-isearch-history)       ;; orig. isearch-edit-string
         ;;("M-s l" . consult-line)                  ;; needed by consult-line to detect isearch
         ;;("M-s L" . consult-line-multi)            ;; needed by consult-line to detect isearch
         ;; Minibuffer history
         :map minibuffer-local-map
         ("M-s" . consult-history)                 ;; orig. next-matching-history-element
         ("M-r" . consult-history))                ;; orig. previous-matching-history-element

  ;; Enable automatic preview at point in the *Completions* buffer. This is
  ;; relevant when you use the default completion UI.
  :hook (completion-list-mode . consult-preview-at-point-mode)

  ;; The :init configuration is always executed (Not lazy)
  :init

  ;; Optionally configure the register formatting. This improves the register
  ;; preview for `consult-register', `consult-register-load',
  ;; `consult-register-store' and the Emacs built-ins.
  (setq register-preview-delay 0.5
        register-preview-function #'consult-register-format)

  ;; Optionally tweak the register preview window.
  ;; This adds thin lines, sorting and hides the mode line of the window.
  (advice-add #'register-preview :override #'consult-register-window)

  ;; Use Consult to select xref locations with preview
  (setq xref-show-xrefs-function #'consult-xref
        xref-show-definitions-function #'consult-xref)

  ;; Configure other variables and modes in the :config section,
  ;; after lazily loading the package.
  :config

  ;; Optionally configure preview. The default value
  ;; is 'any, such that any key triggers the preview.
  ;; (setq consult-preview-key 'any)
  ;; (setq consult-preview-key "M-.")
  ;; (setq consult-preview-key '("S-<down>" "S-<up>"))
  ;; For some commands and buffer sources it is useful to configure the
  ;; :preview-key on a per-command basis using the `consult-customize' macro.
  (consult-customize
   consult-theme :preview-key '(:debounce 0.2 any)
   consult-ripgrep consult-git-grep consult-grep
   consult-bookmark consult-recent-file consult-xref
   consult--source-bookmark consult--source-file-register
   consult--source-recent-file consult--source-project-recent-file
   ;; :preview-key "M-."
   :preview-key '(:debounce 0.4 any))

  ;; Optionally configure the narrowing key.
  ;; Both < and C-+ work reasonably well.
  (setq consult-narrow-key "<") ;; "C-+"

  ;; Optionally make narrowing help available in the minibuffer.
  ;; You may want to use `embark-prefix-help-command' or which-key instead.
  ;; (define-key consult-narrow-map (vconcat consult-narrow-key "?") #'consult-narrow-help)

  ;; By default `consult-project-function' uses `project-root' from project.el.
  ;; Optionally configure a different project root function.
  ;;;; 1. project.el (the default)
  ;; (setq consult-project-function #'consult--default-project--function)
  ;;;; 2. vc.el (vc-root-dir)
  ;; (setq consult-project-function (lambda (_) (vc-root-dir)))
  ;;;; 3. locate-dominating-file
  ;; (setq consult-project-function (lambda (_) (locate-dominating-file "." ".git")))
  ;;;; 4. projectile.el (projectile-project-root)
   (autoload 'projectile-project-root "projectile")
   (setq consult-project-function (lambda (_) (projectile-project-root)))
  ;;;; 5. No project support
  ;; (setq consult-project-function nil)
)
#+END_SRC

#+RESULTS:
: consult-history

** Embark
Let's =embark= on a journey! Embark allows us to operate on a line or selection, called /target/ to see the actions available. It interacts quite well with =consult=. More info here: https://github.com/oantolin/embark/
#+BEGIN_SRC emacs-lisp
(use-package embark
  :ensure t
  :bind
  (("C-=" . embark-act)         ;; pick some comfortable binding
   ("C-;" . embark-dwim)        ;; good alternative: M-.
   ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'

  :init

  ;; Optionally replace the key help with a completing-read interface
  (setq prefix-help-command #'embark-prefix-help-command)

  :config

  ;; Hide the mode line of the Embark live/completions buffers
  (add-to-list 'display-buffer-alist
               '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                 nil
                 (window-parameters (mode-line-format . none)))))

;; Consult users will also want the embark-consult package.
(use-package embark-consult
  :ensure t
  :after (embark consult)
  :demand t ; only necessary if you have the hook below
  ;; if you want to have consult previews as you move around an
  ;; auto-updating embark collect buffer
  :hook
  (embark-collect-mode . consult-preview-at-point-mode))
#+END_SRC

#+RESULTS:

** Which key setup
=which-key= is a very useful utility which pops up a menu when you enter the beginning of a keybinding. It lets you know what keybindings are available and what they do. Very useful for learning, or even for lesser used commands. Which key documentation can be found here: https://github.com/justbur/emacs-which-key
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :init (which-key-mode)
  :diminish which-key-mode
  :config
  (setq which-key-idle-delay 1))
#+END_SRC

#+RESULTS:
: t

** Yasnippet
Yet another snippet manager.... Wait, what's a snippet? A snippet is a small abbreviation for a much larger structure or name. You simply type the snippet, press tab and it expands fully, saving you a significant amount of time. More info on how to build them and how the tool works can be found here: https://github.com/joaotavora/yasnippet
There are official snippets which are already made for your convenience, nicely provided by the =yasnippet-snippets=  package, whose documentation can be found here:https://github.com/AndreaCrotti/yasnippet-snippets
#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :ensure t
  :config
  (setq yas-indent-line 'fixed)
  (yas-global-mode))
(use-package yasnippet-snippets
  :ensure t)
#+END_SRC

#+RESULTS:

** Company mode
Always be in good company with =company-mode=. It provides in-buffer completions which is a great help when programming, helping out and providing useful function names and so on. Note that =company-mode= is a front-end which will need backends for the various modes it is used in. More info on company ;ode can be found here: https://company-mode.github.io/ .
An alternative to this is corfu, info available here: https://github.com/minad/corfu
#+BEGIN_SRC emacs-lisp
  ;; (use-package company
  ;; :hook
  ;; (after-init . global-company-mode))

  ;; (use-package company-box
  ;; :hook (company-mode . company-box-mode))
#+END_SRC

#+RESULTS:

#+begin_src emacs-lisp
   (use-package corfu
     ;; Optional customizations
      :custom
      (corfu-cycle t)                ;; Enable cycling for `corfu-next/previous'
      (corfu-auto t)                 ;; Enable auto completion
     ;; (corfu-separator ?\s)          ;; Orderless field separator
     ;; (corfu-quit-at-boundary nil)   ;; Never quit at completion boundary
     ;; (corfu-quit-no-match nil)      ;; Never quit, even if there is no match
      (corfu-preview-current nil)    ;; Disable current candidate preview
      (corfu-preselect 'prompt)      ;; Preselect the prompt
     ;; (corfu-on-exact-match nil)     ;; Configure handling of exact matches
     ;; (corfu-scroll-margin 5)        ;; Use scroll margin

     ;; Enable Corfu only for certain modes.
     ;; :hook ((prog-mode . corfu-mode)
     ;;        (shell-mode . corfu-mode)
     ;;        (eshell-mode . corfu-mode))

     ;; Recommended: Enable Corfu globally.
     ;; This is recommended since Dabbrev can be used globally (M-/).
     ;; See also `corfu-excluded-modes'.
     :init
     (global-corfu-mode))
   ;; Enable auto completion and configure quitting

   ;; A few more useful configurations...
   (use-package emacs
     :init
     ;; TAB cycle if there are only few candidates
     (setq completion-cycle-threshold 3)

     ;; Emacs 28: Hide commands in M-x which do not apply to the current mode.
     ;; Corfu commands are hidden, since they are not supposed to be used via M-x.
     ;; (setq read-extended-command-predicate
     ;;       #'command-completion-default-include-p)

     ;; Enable indentation+completion using the TAB key.
     ;; `completion-at-point' is often bound to M-TAB.
     (setq tab-always-indent 'complete))

   (use-package dabbrev
   ;; Swap M-/ and C-M-/
   :bind (("M-/" . dabbrev-completion)
          ("C-M-/" . dabbrev-expand))
   ;; Other useful Dabbrev configurations.
   :custom
   (dabbrev-ignored-buffer-regexps '("\\.\\(?:pdf\\|jpe?g\\|png\\)\\'")))

   (use-package kind-icon
   :ensure t
   :after corfu
   :custom
   (kind-icon-default-face 'corfu-default) ; to compute blended backgrounds correctly
   :config
   (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter))
#+end_src
#+RESULTS:
: t

** Autopair
Generally, when one opens a parentheses, one intends to close it.
#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :ensure t
    :config
    (progn 
      (setq sp-show-pair-from-inside nil)
      (smartparens-global-mode 1)))
  (require 'smartparens-config)
#+END_SRC

#+RESULTS:
: smartparens-config

** Citar
Citar is a bibliographic reference manager for emacs. It handles bibliographies in BibTeX for org, markdown and LaTeX. More info here: https://github.com/bdarcus/citar
#+BEGIN_SRC emacs-lisp
 (use-package citar
   :bind (("C-c b" . citar-insert-citation)
          :map minibuffer-local-map
          ("M-b" . citar-insert-preset))
   :custom
   (citar-bibliography '("~/Documents/Stage/rapport_prov.bib")))
 (advice-add #'completing-read-multiple :override #'consult-completing-read-multiple)

(use-package biblio)
#+END_SRC

#+RESULTS:

** CTRLF
CTRLF is a drop in replacement for Isearch made by radian. More info here [[https://github.com/radian-software/ctrlf#why-not-isearch]]
#+begin_src emacs-lisp
  (use-package ctrlf)
  (ctrlf-mode +1)

#+end_src

#+RESULTS:
: t

* Popper.el
#+BEGIN_SRC emacs-lisp
  (use-package popper
  :ensure t ; or :straight t
  :bind (("C-)"   . popper-toggle-latest)
         ("C-:"   . popper-cycle)
         ("C-M-)" . popper-toggle-type))
  :init
  (setq popper-reference-buffers
        '("\\*Messages\\*"
          "\\*Warnings\\*"
          "Output\\*$"
          "\\*Async Shell Command\\*"
        "\\*Fancy Diary Entries\\*"
          help-mode
          helpful-mode
          compilation-mode))
  (popper-mode +1)
  (popper-echo-mode +1))                ; For echo area hints

#+END_SRC

#+RESULTS:
: popper-toggle-type

* Evil mode
Don't like emacs buffer keybindings? COME TO THE DARK SIDE, WE HAVE VIM! =evil-mode= is a tool which emulates vim keybindings in emacs along with the modes. This allows a true vim experience, and brings a great editor to a great operating system. On top of the usual evil stuff, you might want extra keybindings for modes not covered by =evil-mode=. You can get these through =evil-collection= and it will allow for better consistency throughout your emacs experience. Extra help for =evil-mode= can be found here: https://evil.readthedocs.io/en/latest/index.html
For =evil-collection= look here: https://github.com/emacs-evil/evil-collection
#+BEGIN_SRC emacs-lisp
  (use-package evil
    :init
    (setq evil-want-integration t)
    (setq evil-want-keybinding nil)
    (setq evil-want-C-i-jump nil)
    :config
    (evil-mode 1)
    (define-key evil-insert-state-map (kbd "C-g") 'evil-normal-state)
    (define-key evil-insert-state-map (kbd "C-h") 'evil-delete-backward-char-and-join)

    ;; Use visual line motions even outside of visual-line-mode buffers
    (evil-global-set-key 'motion "j" 'evil-next-visual-line)
    (evil-global-set-key 'motion "k" 'evil-previous-visual-line)

    (evil-set-initial-state 'messages-buffer-mode 'normal)
    (evil-set-initial-state 'dashboard-mode 'normal))

(use-package evil-collection
    :after evil
    :custom
    (evil-collection-setup-minibuffer nil)
    :config
    (evil-collection-init))
  (use-package dash)
#+END_SRC

#+RESULTS:

* Org-mode setup
Time to meet the reason you (probably) use emacs: =org-mode=! =org-mode= is a markup language and a note taking system designed to be exported to anything. It's useful to write \LaTeX (without actually needing to write \LaTeX), do literate programming, write websites or books, take notes, prepare presentations and so on. Thanks to its intuitive nature and being so much more powerful than other markup languages it can easily take over all your writing needs. It also includes the agenda for keeping track of tasks and a roam-like database tool. It is almost infinitely extensible so have fun! All of the =org-mode= help can be found on the website [[https://orgmode.org]] !

** Basic org-mode functionnality
Here we establish the basic Org-mode functionality. While complicated, it is mostly plagiarized from David Wilson's "Emacs from scratch" excellent video series. You can find the config here: https://github.com/daviwil/emacs-from-scratch/blob/master/Emacs.org ! In our case we simply load =org-mode= here and setup fonts, agenda location, and centers the buffer if used in full screen to lessen eye strain. We also use =pretty-bullets= just for /aesthetic/ purposes.
#+BEGIN_SRC emacs-lisp
     (defun efs/org-mode-setup ()
     (org-indent-mode)
     (variable-pitch-mode 1)
     (evil-org-mode 1)
     (set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch))
     ;(setq org-agenda-include-diary t))

   (defun efs/org-font-setup () ;; Replace list hyphen with dot
     (font-lock-add-keywords 'org-mode
                             '(("^ *\\([-]\\) "
                                (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))

     ;; Set faces for heading levels
     (dolist (face '((org-level-1 . 1.2)
                     (org-level-2 . 1.1)
                     (org-level-3 . 1.05)
                     (org-level-4 . 1.0)
                     (org-level-5 . 1.1)
                     (org-level-6 . 1.1)
                     (org-level-7 . 1.1)
                     (org-level-8 . 1.1)))
       (set-face-attribute (car face) nil :font "Roboto" :weight 'regular :height (cdr face)))

     ;; Ensure that anything that should be fixed-pitch in Org files appears that way
     (set-face-attribute 'org-block nil :foreground nil :inherit 'fixed-pitch)
     (set-face-attribute 'org-code nil   :inherit '(shadow fixed-pitch))
     (set-face-attribute 'org-table nil   :inherit '(shadow fixed-pitch))
     (set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
     (set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
     (set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
     (set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch))

   ;; ;(setq calendar-week-start-day 0
   ;;       calendar-day-name-array ["Dimanche" "Lundi" "Mardi" "Mercredi" "Jeudi" "Vendredi" "Samedi"]
   ;;       calendar-month-name-array ["Janvier" "Février" "Mars" "Avril" "Mai" "Juin" "Juillet" "Août" "Septembre"
   ;;                                  "Octobre" "Novembre" "Décembre"])
   (use-package org
     :hook ((org-mode . efs/org-mode-setup))
     :config
      (setq org-ellipsis " ⤵")
      (efs/org-font-setup)
      (setq org-agenda-start-with-log-mode t)
      (setq org-log-done 'time)

      (setq org-done-into-drawer t)
      (setq org-agenda-files
            '("~/Agenda/" "~/Documents/RoamNotes/" "~/org/todo.org"))
      (setq org-todo-keywords
            '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d!")
              (sequence "BACKLOG(b)" "PLAN(p)" "READY(r)" "ACTIVATE(a)" "REVIEW(v)" "WAIT(w@/!)" "|" "COMPLETED(c)" "CANCELLED(k@)")))
     ;; Configure custom agenda views
      (setq org-agenda-custom-commands
       '(("d" "Dashboard"
         ((agenda "" ((org-deadline-warning-days 7)))
          (todo "NEXT"
            ((org-agenda-overriding-header "Next Tasks")))
          (tags-todo "agenda/ACTIVE" ((org-agenda-overriding-header "Active Projects")))))

        ("n" "Next Tasks"
         ((todo "NEXT"
            ((org-agenda-overriding-header "Next Tasks")))))

        ("W" "Work Tasks" tags-todo "+work-email")

        ;; Low-effort next actions
        ("e" tags-todo "+TODO=\"NEXT\"+Effort<15&+Effort>0"
         ((org-agenda-overriding-header "Low Effort Tasks")
          (org-agenda-max-todos 20)
          (org-agenda-files org-agenda-files)))

        ("w" "Workflow Status"
         ((todo "WAIT"
                ((org-agenda-overriding-header "Waiting on External")
                 (org-agenda-files org-agenda-files)))
          (todo "REVIEW"
                ((org-agenda-overriding-header "In Review")
                 (org-agenda-files org-agenda-files)))
          (todo "PLAN"
                ((org-agenda-overriding-header "In Planning")
                 (org-agenda-todo-list-sublevels nil)
                 (org-agenda-files org-agenda-files)))
          (todo "BACKLOG"
                ((org-agenda-overriding-header "Project Backlog")
                 (org-agenda-todo-list-sublevels nil)
                 (org-agenda-files org-agenda-files)))
          (todo "READY"
                ((org-agenda-overriding-header "Ready for Work")
                 (org-agenda-files org-agenda-files)))
          (todo "ACTIVE"
                ((org-agenda-overriding-header "Active Projects")
                 (org-agenda-files org-agenda-files)))
          (todo "COMPLETED"
                ((org-agenda-overriding-header "Completed Projects")
                 (org-agenda-files org-agenda-files)))
          (todo "CANC"
                ((org-agenda-overriding-header "Cancelled Projects")
                 (org-agenda-files org-agenda-files)))))))
      (efs/org-font-setup))

   (defun efs/org-mode-visual-fill ()
     (setq visual-fill-column-width 120
           visual-fill-column-center-text t)
     (visual-fill-column-mode 1))

   (use-package org-bullets
      :after org
      :hook (org-mode . org-bullets-mode)
      :custom
      (org-bullets-bullet-list '("◉" "○" "●" "○" "●" "○" "●")))

  (use-package visual-fill-column
    :hook ((org-mode . efs/org-mode-visual-fill)
           (latex-mode . efs/org-mode-visual-fill)
           (LaTeX-mode . efs/org-mode-visual-fill)))

  (setq org-use-speed-commands t)
  (setq org-image-actual-width 550)
  (setq org-highlight-latex-and-related '(latex script entities))
#+END_SRC

#+RESULTS:
| latex | script | entities |

Lets add image animation to this configuration
#+begin_src emacs-lisp
  (use-package org-inline-anim)
  (add-hook 'org-mode-hook #'org-inline-anim-mode)
#+end_src

#+RESULTS:
| org-ref-org-menu | (lambda nil evil-org-mode) | org-tempo-setup | org-inline-anim-mode | efs/org-mode-visual-fill | org-bullets-mode | efs/org-mode-setup | #[0 \301\211\207 [imenu-create-index-function org-imenu-get-tree] 2] | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-show-all append local] 5] | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-babel-show-result-all append local] 5] | org-babel-result-hide-spec | org-babel-hide-all-hashes |

** Get latest Calendar at emacs startup
#+begin_src emacs-lisp
  (call-process "/usr/bin/icsorg")
(add-hook 'org-agenda-mode-hook (lambda () (call-process "/usr/bin/icsorg")))
#+end_src

#+RESULTS:
| lambda | nil | (call-process /usr/bin/icsorg) |

** Org languages support
What would =org-mode= be without any language support? Here we get =org-mode= ready to support more languages that we find useful. We can always add some after, if we need them. We also tell org to not ask for confirmation when executing code in a block.
#+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '((emacs-lisp . t)
   (python . t)
   (C . t)
   (java . t)
   (octave . t)
   (shell . t)
   (latex . t)))

(defun my-org-confirm-babel-evaluate (lang body)
  "Do not confirm evaluation for these languages."
  (not (or (string= lang "C")
           (string= lang "java")
           (string= lang "python")
           (string= lang "emacs-lisp")
           (string= lang "octave"))))
(setq org-confirm-babel-evaluate 'my-org-confirm-babel-evaluate)
(setq org-confirm-babel-evaluate nil)
#+END_SRC

#+RESULTS:

** Source block templates
These are just some nice templates to shorten the time needed to write some structures. Not too needed since =yasnippet= is here to help.
#+BEGIN_SRC emacs-lisp
(require 'org-tempo)

(add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
(add-to-list 'org-structure-template-alist '("py" . "src python"))
(add-to-list 'org-structure-template-alist '("sh" . "src sh"))
#+END_SRC

#+RESULTS:
: ((sh . src sh) (py . src python) (el . src emacs-lisp) (a . export ascii) (c . center) (C . comment) (e . example) (E . export) (h . export html) (l . export latex) (q . quote) (s . src) (v . verse))

** Org-export stuff
Let's add some org exporters! Easy to tell they are all called =ox=. =ox-pandoc= uses, you guessed it, =pandoc= to add all kinds of exporting capabilities. You can add more if necessary.
#+BEGIN_SRC emacs-lisp
  (use-package ox-pandoc
    :no-require t
    :defer 10
    :ensure t)

  (eval-after-load "org"
  '(require 'ox-md nil t))
#+END_SRC

#+RESULTS:
: ox-md

** Org reveal
Who likes clean and minimalist HTML presentations? Only me? OK then... =org-reveal= is a neat tool which allows us to create nice /reveal.js/ presentations directly from =org-mode= which is *very* neat. Just put the reveal root to this website, remember to have an internet connection handy! Here is where you can get /reveal.js/ documentation: https://revealjs.com/
Here is where you can get info for the exporter: https://github.com/hexmode/ox-reveal
Keep in mind that =htmlize= is a dependency.
#+BEGIN_SRC emacs-lisp
(use-package ox-reveal
  :ensure ox-reveal)

(setq org-reveal-root "https://cdn.jsdelivr.net/npm/reveal.js")
(setq org-reveal-mathjax t)

(use-package htmlize
  :ensure t)
#+END_SRC

#+RESULTS:

** Extra keybindings 
Let's add a few keybindings to help along with capture and agenda. More importantly lets add =evil-org= to enable even more nice (and evil) keybindings to be used. The documentation can be found here: https://github.com/Somelauw/evil-org-mode
#+BEGIN_SRC emacs-lisp
(bind-key "C-c c" 'org-capture)
(bind-key "C-c a" 'org-agenda)

(use-package evil-org
  :ensure t
  :after org
  :hook (org-mode . (lambda () evil-org-mode))
  :config
  (require 'evil-org-agenda)
  (evil-org-agenda-set-keys))

#+END_SRC

#+RESULTS:
| org-ref-org-menu | (lambda nil evil-org-mode) | org-tempo-setup | org-inline-anim-mode | efs/org-mode-visual-fill | org-bullets-mode | efs/org-mode-setup | #[0 \301\211\207 [imenu-create-index-function org-imenu-get-tree] 2] | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-show-all append local] 5] | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-babel-show-result-all append local] 5] | org-babel-result-hide-spec | org-babel-hide-all-hashes |

** Org roam
Lets build a second brain! =Org-roam= is a tool that allows you to take notes and to arrange them Zettelkasten style. There is a very nice video on the System Crafters Youtube channel: https://www.youtube.com/watch?v=AyhPmypHDEw
Go check the video out, and the others in the series!
Extra org-roam documentation can be found here: https://www.orgroam.com/
#+begin_src emacs-lisp
(use-package org-roam
  :ensure t
  :init
  (setq org-roam-v2-ack t)
  (setq org-roam-dailies-directory "~/Documents/dailies")

  :custom
  (org-roam-directory "~/Documents/RoamNotes")
  (org-roam-completion-everywhere t)
  :bind (("C-c n l" . org-roam-buffer-toggle)
         ("C-c n f" . org-roam-node-find)
         ("C-c n i" . org-roam-node-insert)
         ("C-c n I" . org-roam-node-insert-immediate)
         :map org-mode-map
         ("C-M-i" . completion-at-point))
  ;;:bind-keymap
  ;;("C-c n d" . org-roam-dailies-map)
  :config
  (org-roam-setup))

(defun org-roam-node-insert-immediate (arg &rest args)
(interactive "P")
(let ((args (cons arg args))
      (org-roam-capture-templates (list (append (car org-roam-capture-templates)
                                                '(:immediate-finish t)))))
  (apply #'org-roam-node-insert args)))
#+END_SRC

#+RESULTS:
: org-roam-node-insert-immediate

** Org-ref
Org-ref comes with org-mode already, all we need to do is to set it up properly
#+begin_src emacs-lisp
  (use-package bibtex-completion)
  (use-package org-ref)
  (setq bibtex-completion-bibliography'("~/bib/references.bib")
        bibtex-completion-library-path '("")
        bibtex-completion-notes-path "~/bib/pdf/"
        bibtex-completion-notes-template-multiple-files "* ${author-or-editor}, ${title}, ${journal}, (${year}) :${=type=}: \n\nSee [[cite:&${=key=}]]\n"

        bibtex-completion-additional-search-fields '(keywords)
        bibtex-completion-display-formats
        '((article       . "${=has-pdf=:1}${=has-note=:1} ${year:4} ${author:36} ${title:*} ${journal:40}")
          (inbook        . "${=has-pdf=:1}${=has-note=:1} ${year:4} ${author:36} ${title:*} Chapter ${chapter:32}")
          (incollection  . "${=has-pdf=:1}${=has-note=:1} ${year:4} ${author:36} ${title:*} ${booktitle:40}")
          (inproceedings . "${=has-pdf=:1}${=has-note=:1} ${year:4} ${author:36} ${title:*} ${booktitle:40}")
          (t             . "${=has-pdf=:1}${=has-note=:1} ${year:4} ${author:36} ${title:*}"))
        bibtex-completion-pdf-open-function
        (lambda (fpath)
          (call-process "open" nil 0 nil fpath)))
#+end_src

            #+RESULTS:
            | lambda | (fpath) | (call-process open nil 0 nil fpath) |

** Org capture templates
Here we create org-capture templates for quick and easy note taking
#+BEGIN_SRC emacs-lisp
(setq org-capture-templates
    '(("t" "Todo" entry (file+headline "~/org/todo.org" "Tasks")
       "* TODO %?\n  %i\n  %a")
      ("j" "Journal" entry (file+datetree "~/org/journal.org")
       "* %?\nEntered on %U\n  %i\n  %a")))
#+END_SRC

#+RESULTS:
| t | Todo | entry | (file+headline ~/org/todo.org Tasks) | * TODO %? |

** Org-calendar sync with Outlook

#+begin_src emacs-lisp
  ;; (use-package excorporate
  ;;   :demand t
  ;;   :ensure t)    
  ;; (evil-define-key 'motion calendar-mode-map "e" #'exco-calendar-show-day)

  ;; (setq-default
  ;;         ;; configure email address and office 365 exchange server adddress for exchange web services
  ;;  excorporate-configuration
  ;;  (quote
  ;;   ("Simon.Meyer@bmedicalsystems.com" .
  ;;    "https://mail.bmedicalsystems.com/EWS/Exchange.asmx"))
  ;;  org-agenda-include-diary nil
  ;;  )
  ;;        ;; enable the diary integration (i.e. write exchange calendar to emacs diary file -> ~/.emacs.d/diary must exist)
  ;;        ;;(excorporate-diary-disable)
  ;;        ;; activate excorporate and request user/password to start connection
  ;;        ;;(excorporate)

  ;;        ;(defun ab/agenda-update-diary ()
  ;;        ;  "call excorporate to update the diary for today"
  ;;        ;  (exco-diary-diary-advice (calendar-current-date) (calendar-current-date) #'message "diary updated"))
  ;;        ;; update the diary every time the org agenda is refreshed
  ;;      ;"Fetch daily meetings and commitments and save to daily org file"

  ;; (defun sm/get-exco-org-days(&optional arg)
  ;;   "Fetch today's appointments to org buffer"
  ;;   (interactive "P")
  ;;   (if (not arg) (setq arg 0)) 
  ;;   (let ((count 0))
  ;;     (while (< count arg)
  ;;        (progn
  ;;          (apply excorporate-calendar-show-day-function (calendar-current-date arg))
  ;;          (cl-incf count)))))
  ;;  (defun sm/save-exorg-to-file (month day year)
  ;;    "Save excorporate org file to Agenda folder"
  ;;  (with-current-buffer excorporate-org-buffer-name
  ;;    (progn (write-region nil nil
  ;;      (concat "~/Agenda/exco-"
  ;;        (format "%d-%d-%d" day month year)
  ;;        ".org")
  ;;      (kill-buffer))
  ;;      nil
  ;;      nil)))

  ;; (excorporate)
  ;; ;(run-with-timer 5 nil #'progn 
  ;;  ;                    (sm/get-exco-org-days))
  ;; (add-hook 'org-agenda-mode-hook #'sm/get-exco-org-days)


#+end_src

#+RESULTS:

* Project Management
Here are out project management tools, the incredible =magit= and the presitgious =projectile=.
** Magit
Git is useful. Git is also annoying with it's long to input commands. Can this problem be solved, I wonder? Enter =magit= a brilliant wrapper which provides the *entire* functionnality of git in a simple and fast system which neatly integrates with emacs. Very, very nice. All of the info one can dream of is here: https://magit.vc/
We also add =forge= along which is made by the same creator which allows communication and use with tools such as GitHub and Gitlab! An essential for any =magit= user... All of the necessary info can be found here: https://magit.vc/manual/forge/
#+BEGIN_SRC emacs-lisp
  (use-package magit
     :ensure t
     :defer t
     :bind (("C-c g" . magit-status)
           ("C-c G" . magit-dispatch)
            ;("C-c m l" . magit-log-buffer-file)
            ;("C-c m b" . magit-blame))
         )
     :config
     (setq magit-display-buffer-function 'magit-display-buffer-same-window-except-diff-v1)
     (setq magit-diff-refine-hunk t))

   (use-package forge
     :ensure t
     :after magit)
#+END_SRC

#+RESULTS:

** Projectile
=projectile= is a project integration library for emacs whose goal is.... blah blah blah. It makes it so emacs can only "see" the current project directory and therfore declutter and remove other files or buffers which could be distracting you. It also provides individual features to navigate the project, search in the project, runs tests and so on. All the docs are available here for your reading /pleasure/:  https://projectile.mx/
#+BEGIN_SRC emacs-lisp
(use-package projectile
  :ensure t
  :diminish projectile-mode
  :commands (projectile-mode projectile-switch-project)
  :bind (("C-c p p" . projectile-switch-project)
         ("C-c p s s" . projectile-ag)
         ("C-c p s r" . projectile-ripgrep))
  :config
  (setq projectile-keymap-prefix (kbd "C-c p"))
  (projectile-global-mode t)
  (setq projectile-enable-caching t)
  (setq projectile-switch-project-action 'projectile-dired))
#+END_SRC

#+RESULTS:
: projectile-ripgrep

** Treemacs
Nothing quite like seeing the project files for the current project is there? This is what =treemacs= does, and it helps a lot. For more info go visit: [[https://github.com/Alexander-Miller/treemacs]].
#+BEGIN_SRC emacs-lisp
  (use-package treemacs
    :ensure t
    :defer t
    :init
    (with-eval-after-load 'winum
      (define-key winum-keymap (kbd "M-0") #'treemacs-select-window))
    :config
    (progn
      (setq treemacs-collapse-dirs                   (if treemacs-python-executable 3 0)
            treemacs-deferred-git-apply-delay        0.5
            treemacs-directory-name-transformer      #'identity
            treemacs-display-in-side-window          t
            treemacs-eldoc-display                   'simple
            treemacs-file-event-delay                2000
            treemacs-file-extension-regex            treemacs-last-period-regex-value
            treemacs-file-follow-delay               0.2
            treemacs-file-name-transformer           #'identity
            treemacs-follow-after-init               t
            treemacs-expand-after-init               t
            treemacs-find-workspace-method           'find-for-file-or-pick-first
            treemacs-git-command-pipe                ""
            treemacs-goto-tag-strategy               'refetch-index
            treemacs-header-scroll-indicators        '(nil . "^^^^^^")
            treemacs-hide-dot-git-directory          t
            treemacs-indentation                     2
            treemacs-indentation-string              " "
            treemacs-is-never-other-window           nil
            treemacs-max-git-entries                 5000
            treemacs-missing-project-action          'ask
            treemacs-move-forward-on-expand          nil
            treemacs-no-png-images                   nil
            treemacs-no-delete-other-windows         t
            treemacs-project-follow-cleanup          nil
            treemacs-persist-file                    (expand-file-name ".cache/treemacs-persist" user-emacs-directory)
            treemacs-position                        'left
            treemacs-read-string-input               'from-child-frame
            treemacs-recenter-distance               0.1
            treemacs-recenter-after-file-follow      nil
            treemacs-recenter-after-tag-follow       nil
            treemacs-recenter-after-project-jump     'always
            treemacs-recenter-after-project-expand   'on-distance
            treemacs-litter-directories              '("/node_modules" "/.venv" "/.cask")
            treemacs-show-cursor                     nil
            treemacs-show-hidden-files               t
            treemacs-silent-filewatch                nil
            treemacs-silent-refresh                  nil
            treemacs-sorting                         'alphabetic-asc
            treemacs-select-when-already-in-treemacs 'move-back
            treemacs-space-between-root-nodes        t
            treemacs-tag-follow-cleanup              t
            treemacs-tag-follow-delay                1.5
            treemacs-text-scale                      nil
            treemacs-user-mode-line-format           nil
            treemacs-user-header-line-format         nil
            treemacs-wide-toggle-width               70
            treemacs-width                           35
            treemacs-width-increment                 1
            treemacs-width-is-initially-locked       t
            treemacs-workspace-switch-cleanup        nil)

      ;; The default width and height of the icons is 22 pixels. If you are
      ;; using a Hi-DPI display, uncomment this to double the icon size.
      ;;(treemacs-resize-icons 44)

      (treemacs-follow-mode t)
      (treemacs-filewatch-mode t)
      (treemacs-indent-guide-mode t)
      (treemacs-fringe-indicator-mode 'always)
      (when treemacs-python-executable
        (treemacs-git-commit-diff-mode t))

      (pcase (cons (not (null (executable-find "git")))
                   (not (null treemacs-python-executable)))
        (`(t . t)
         (treemacs-git-mode 'deferred))
        (`(t . _)
         (treemacs-git-mode 'simple)))

      (treemacs-hide-gitignored-files-mode nil))
    :bind
    (:map global-map
          ("M-0"       . treemacs-select-window)
          ("C-x t 1"   . treemacs-delete-other-windows)
          ("C-x t t"   . treemacs)
          ("C-x t d"   . treemacs-select-directory)
          ("C-x t B"   . treemacs-bookmark)
          ("C-x t C-t" . treemacs-find-file)
          ("C-x t M-t" . treemacs-find-tag)))

  (use-package treemacs-evil
    :after (treemacs evil)
    :ensure t)

  (use-package treemacs-projectile
    :after (treemacs projectile)
    :ensure t)

  (use-package treemacs-icons-dired
    :hook (dired-mode . treemacs-icons-dired-enable-once)
    :ensure t)

  (use-package treemacs-magit
    :after (treemacs magit)
    :ensure t)

  ;; (use-package treemacs-persp ;;treemacs-perspective if you use perspective.el vs. persp-mode
  ;;   :after (treemacs persp-mode) ;;or perspective vs. persp-mode
  ;;   :ensure t
  ;;   :config (treemacs-set-scope-type 'Perspectives))

  (use-package treemacs-tab-bar ;;treemacs-tab-bar if you use tab-bar-mode
    :after (treemacs)
    :ensure t
    :config (treemacs-set-scope-type 'Tabs))
#+END_SRC

#+RESULTS:
: t

** Doxygen
=Doxygen= is a very useful tool to construct documentation for code. We will add =doxygen= support for  C code by using =gendoxy= on emacs. More information on [[https://www.doxygen.nl/index.html][doxygen]] . Gendoxy Github page can be found [[https://github.com/mp81ss/gendoxy][here]].
#+begin_src emacs-lisp
 (load "~/.emacs.d/gendoxy/gendoxy.el") 
#+end_src

#+RESULTS:
: t

* Syntax and Checkers
** Syntax checking
In programming, syntax is sorta important. Like really, have you ever forgotten a =;= in C?? Luckily we can have some help on the /fly/. Introducing =flycheck=, a utility which will check your syntax for you and will aggressively yell at you if you do something wrong. Here is the help to use this package: https://www.flycheck.org/en/latest/
#+BEGIN_SRC emacs-lisp
 (use-package flycheck
   :ensure t
   :defer t
   :init
   (global-flycheck-mode))
#+END_SRC

#+RESULTS:
: t

** Emacs langtool
Natural languages can be harder to correct. The default systems available on Linux simply compare the words to a premade dictionnary with trivial rules. Luckily we can do better, with [[https://languagetool.org/][Language tool]]! This is open-source software which you allows us to detect spelling and also grammar mistakes. It isn't perfect but it's already much better. They have a subscription plan but you can deploy your own server, which is what is done here. Emacs implementation here: https://github.com/mhayashi1120/Emacs-langtool. 
#+BEGIN_SRC emacs-lisp 
  (use-package langtool
  :init (setq langtool-http-server-host "localhost"
              langtool-http-server-port 8081)
        (if (not (get-buffer " langtool"))
            (start-process "langtool" (get-buffer-create " langtool") "languagetool" "--http")))                               
#+END_SRC

#+RESULTS:

** Eldoc-box
=eldoc= is a very useful tool to have access to documentation. It is unfortunately intrusive by constantly poping up below, so we try to resolv this problem by having a tooltip instead.
#+begin_src emacs-lisp
(use-package eldoc-box)
#+end_src

#+RESULTS:

* Arduino
Arduino boards... Kinda nice but how do we program them in emacs?? Well =platformIO= is here to help.
** PlatformIO
=platformio-mode= is here to provide a wrapper for the PlatformIO underlying service to help us out with the boards. Everything else is just c++ shenanigans...
Here are the docs as usual: https://github.com/ZachMassia/platformio-mode
#+BEGIN_SRC emacs-lisp
(use-package platformio-mode
  :init (add-hook 'c++-mode-hook (lambda ()
                                   (platformio-conditionally-enable))))
#+END_SRC

#+RESULTS:

* Programming languages support
Delegating is sometimes necessary, isn't it? Here we are delegating most of our programming completions to lsp servers with =eglot=. Quite useful, isn't it?
#+BEGIN_SRC emacs-lisp
      (use-package eglot
        :commands (eglot eglot-ensure)
        :hook (
               (c-mode . eglot-ensure)
               (c++-mode . eglot-ensure)
               (python-mode . eglot-ensure)
               (latex-mode . eglot-ensure)
               (xenops-mode . eglot-ensure)))
(add-hook 'eglot-managed-mode-hook #'eldoc-box-hover-mode t)

  #+END_SRC

#+RESULTS:
| doom-modeline-override-eglot | doom-modeline-update-eglot | eldoc-box-hover-mode |

** Consult Eglot
Let's add =consult= enhancement on =eglot= to help out further. More info here:  https://github.com/mohkale/consult-eglot

#+begin_src emacs-lisp
  (use-package consult-eglot
    :after eglot)
#+end_src

#+RESULTS:

** Python
Let's add a little python support shall we? Python is already well supported so we'll just add the few tools we need to ease the build.
*** Virtualenv
Let's add a front-end to virtualenv to allow us to use virtual environments!
#+BEGIN_SRC emacs-lisp
(use-package pyvenv)
#+END_SRC

#+RESULTS:

** LaTeX
LaTeX support is easy to add, let's use the LaTeX configuration for impatient scholars
#+BEGIN_SRC emacs-lisp
  (setq auto-mode-alist (cons '("\\.tex$" . LaTeX-mode) auto-mode-alist))

  (add-to-list 'load-path (concat user-emacs-directory "cdlatex/"))
  (require 'cdlatex)
  (add-hook 'LaTeX-mode-hook #'cdlatex-mode)


  (use-package xenops
    :hook ((latex-mode . xenops-mode)
           (LaTeX-mode . xenops-mode)
           (tex-mode . xenops-mode)
           (TeX-mode . xenops-mode)))

  (use-package auctex
    :defer t
    :ensure t
    :config
    ((setq TeX-auto-save t)))

    (add-hook 'LaTeX-mode-hook (lambda ()
                                     (TeX-fold-mode 1)))

    (use-package reftex
      :ensure t
      :defer t
      :hook ((latex-mode . reftex-mode)
             (LaTeX-mode . reftex-mode)
             (tex-mode . reftex-mode)
             (TeX-mode . reftex-mode)))

  (add-hook 'LaTeX-mode-hook #'outline-minor-mode)
  (define-key outline-minor-mode-map (kbd "<tab>") #'outline-cycle) 
  (add-hook 'LaTeX-mode-hook #'prettify-symbols-mode)



  (with-eval-after-load 'tex
    (add-to-list 'safe-local-variable-values
                 '(TeX-command-extra-options . "-shell-escape")))
#+END_SRC

#+RESULTS:

** Common Lisp
#+BEGIN_SRC emacs-lisp
(setq inferior-lisp-program "/usr/bin/sbcl")
(use-package slime)
#+END_SRC

#+RESULTS:

** Epub reader
#+BEGIN_SRC emacs-lisp :results none
(use-package nov)
(add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode))
#+END_SRC

** Paredit mode
This is designed to help with =emacs lisp= development, most notably to balance parenthesis and to ensure balance at all times
#+begin_src emacs-lisp
(use-package paredit)
#+end_src

#+RESULTS:

** C-mode
Let's add disaster mode to enable decompilation to assembly code:
#+begin_src emacs-lisp
(use-package disaster)
#+end_src

#+RESULTS:

* Email and calendar support
Here we add email support in emacs, in order to manage multiple accounts. We use offlineIMAP and notmuch to manage these.
#+BEGIN_SRC emacs-lisp
      (use-package notmuch
        :demand t
        :ensure t
        :bind (:map notmuch-message-mode-map
                    ("C-c C-c" . set-smtp-server-message-send-and-exit))
        )  
      (setq smtp-accounts          ;; Format: Sender Mail address - SMTP Server - Port - Username
              '(("simeyer@protonmail.com" "127.0.0.1" 1025 "simeyer@protonmail.com")
                ("simon.meyer@bmedicalsystems.com" "mail.bmedicalsystems.com" 587 "simon.meyer")))

        (defun set-smtp-server-message-send-and-exit ()
        "Set SMTP server from list of multiple ones and send mail."
        (interactive)
        (message-remove-header "X-Message-SMTP-Method") ;; Remove. We always determine it by the From field
        (let ((sender
               (message-fetch-field "From")))
          (cl-loop for (addr server port usr) in smtp-accounts
                when (string-match addr sender)
                do (message-add-header (format "X-Message-SMTP-Method: smtp %s %d %s" server port usr)))
          (let ((xmess
                 (message-fetch-field "X-Message-SMTP-Method")))
            (if xmess
                (progn
                  (message (format "Sending message using '%s' with config '%s'" sender xmess))
                  (message-send-and-exit))
              (error "Could not find SMTP Server for this Sender address: %s. You might want to correct it or add it to the SMTP Server list 'smtp-accounts'" sender)))))


      (setq starttls-use-gnutls t)
      (setq starttls-gnutls-program "gnutls-cli")
      (setq starttls-extra-arguments nil)

  (setq message-send-mail-function 'smtpmail-send-it)
  (defvar notmuch-unread-mode-line-string "")
  (defvar notmuch-unread-email-count nil)
  (defconst my-mode-line-map (make-sparse-keymap))
  (defun notmuch-unread-count ()
    (setq notmuch-unread-email-count
          (string-to-number
           (replace-regexp-in-string
            "\n" "" (notmuch-command-to-string
                     "count" "tag:unread"))))
    (if (eq notmuch-unread-email-count 0)
        (setq notmuch-unread-mode-line-string "  ")
      (setq notmuch-unread-mode-line-string (format "  %d " notmuch-unread-email-count)))
    (force-mode-line-update))

  (run-at-time nil 10 #'notmuch-unread-count)

    (defun notmuch-open-emails ()
      (interactive)
      (if (eq notmuch-unread-email-count 0) (notmuch-search "*") (notmuch-search "tag:inbox")))
  (setq global-mode-string 
          (append global-mode-string (list '(:eval (propertize notmuch-unread-mode-line-string 'help-echo "notmuch emails" 'mouse-face 'mode-line-highlight 'local-map my-mode-line-map)))))
     (define-key my-mode-line-map 
       (vconcat [mode-line down-mouse-1])
       (cons "hello" 'notmuch-open-emails))
#+END_SRC

#+RESULTS:
: (hello . notmuch-open-emails)

Here we add calendar support:
#+begin_src emacs-lisp
  ;; Fetch calendar
;  (run-at-time nil 60 (lambda () (shell-command "curl https://mail.bmedicalsystems.com/owa/calendar/b53767f6ee15411f9f3f9e76b1a1fcd0@bmedicalsystems.com/ebbfea6375454f6fa75db99e4905fa5716775956803368869501/calendar.ics > /home/simon/calendar.ics &" nil nil)))
#+end_src

#+RESULTS:

* PDF support
In this section we add support to display PDF in emacs. See here for more details: https://github.com/vedang/pdf-tools

#+begin_src emacs-lisp
(use-package pdf-tools)
#+end_src

#+RESULTS:

